/* Testando c√≥digos ass√≠ncronos
√â comum encontrarmos em JavaScript linhas de c√≥digo que possuem comportamento ass√≠ncrono.
Voc√™ j√° conhece tr√™s casos em que comportamentos ass√≠ncronos acontecem: callbacks ,
promises e async/await . Para que possamos testar estes casos, o Jest nos fornece algumas
solu√ß√µes com objetivo de que nossos testes saibam o momento em que a fun√ß√£o a ser testada
foi conclu√≠da, e a informa√ß√£o necess√°ria foi retornada. Isto evita que falsos positivos
aconte√ßam e garante segura√ßa para a aplica√ß√£o. Vamos analisar cada caso separadamente abaixo:
Callbacks: para testar callbacks utilizamos a fun√ß√£o done . Ela √© chamada para sinalizar ao
Jest que o teste dever√° aguardar o retorno da fun√ß√£o callback para que a valida√ß√£o aconte√ßa.
Promises: quando testamos promises devemos retorn√°-la dentro do teste. Lembre-se de utilizar
then quando o retorno for um resolve e catch quando o retorno for um reject .
Async/Await: para testar fun√ß√µes com async e await devemos utilizar a palavra chave async na
fun√ß√£o passada para teste e await onde esperamos algum retorno ass√≠ncrono. Lembre-se que o
async/await √© apenas uma alternativa de sintaxe mais simples para testar promises .
A seguir voc√™ conhecer√° de forma detalhada todos os conceitos apresentados acima. N√£o se
preocupe, existem exemplos e exerc√≠cios para que voc√™ possa colocar a teoria em pr√°tica
e consolidar o aprendizado! üòâ
Callbacks
Ao realizar testes ass√≠ncronos, √© necess√°rio ter cuidado com falso-positivos, pois o Jest n√£o
sabe, por padr√£o, quando √© necess√°rio esperar o t√©rmino da execu√ß√£o de uma fun√ß√£o ass√≠ncrona.
Ou seja, voc√™ roda o teste, o Jest analisa as fun√ß√µes s√≠ncronas, n√£o espera as
ass√≠ncronas terminarem e, dado o final do teste, gera um resultado positivo antes de um eventual
problema numa fun√ß√£o ass√≠ncrona acusar um erro.
O exemplo abaixo gera um falso-positivo: */

test("N√£o deveria passar!", () => {
  setTimeout(() => {
    expect(10).toBe(5);
    console.log('Deveria falhar!')
  }, 500);
});
/* Execute-o na sua m√°quina para ver! Como o setTimeout √© uma fun√ß√£o ass√≠ncrona, o teste
retorna um resultado falso-positivo quando executado dessa forma ‚Äî note, inclusive, que a
frase 'Deveria falhar!' sequer aparece no console. O Jest n√£o espera o test acabar, gerando
esse resultado falso-positivo.
Para o Jest esperar a fun√ß√£o ass√≠ncrona ser finalizada, √© necess√°rio utilizar uma callback
pr√≥pria da biblioteca, chamada done , que precisa ser chamada ap√≥s os testes ass√≠ncronos.
Agora o Jest no exemplo abaixo consegue identificar o erro. */

test("N√£o deveria passar!", done => {
  setTimeout(() => {
    expect(10).toBe(5);
    console.log('Deveria falhar!')
    done();
  }, 500);
});
// Outro exemplo para fixar melhor:

const SumNumbers = (a, b, callback) => {
  setTimeout(() => {
    const result = a + b;
    callback(result);
  }, 500)
}

test('Testando SumNumbers, soma 5 mais 10', done => {
  SumNumbers(5, 10, (result) => {
    expect(result).toBe(15);
    done();
  });
})
/* Quando estiver realizando testes, sempre procure verificar se o seu teste n√£o est√°
exibindo resultados falso-positivos. No exemplo acima, em que o teste est√° passando, basta
mudar o valor final do expect de .toBe(15) para analisar outros cen√°rios.
Mude o valor .toBe(15) para .toBe(10) e verifique. O esperado √© o teste identificar o erro.
Caso isso ocorra, quer dizer que o seu teste est√° correto; caso continue passando e n√£o
encontre o erro, provavelmente seu teste est√° com algum falso-positivo.

Promises:
Para testar uma promise ser√° usado o c√≥digo abaixo. Ele possui um array Animals , contendo
animais com seu nome, idade e tipo.
Observe que a fun√ß√£o findAnimalsByType √© uma promise, respons√°vel por buscar os animais
de determinado tipo no array. Em caso de sucesso, ela retornar√° um resolve com um array de
dados. Em caso de falha, retornar√° um reject com um objeto com a chave error, possuindo uma mensagem. */

const Animals = [
  { name: 'Dorminhoco', age: 1, type: 'Dog' },
  { name: 'Soneca', age: 2, type: 'Dog' },
  { name: 'Pregui√ßa', age: 5, type: 'Cat' },
];

const findAnimalsByType = (type) => (
  new Promise((resolve, reject) => {
    setTimeout(() => {
      const arrayAnimals = Animals.filter((animal) => animal.type === type);
      if (arrayAnimals.length !== 0) {
        return resolve(arrayAnimals);
      }

      return reject({ error: 'N√£o possui esse tipo de animal.' });
    }, 100);
  })
);

const getListAnimals = (type) => (
  findAnimalsByType(type).then(list => list)
);
/* 
O primeiro teste desse c√≥digo verificar√° se, ao chamar a fun√ß√£o getListAnimals com Dog
como par√¢metro, o seu retorno ser√° os dois cachorros do array Animals . */

const Animals = [
  { name: 'Dorminhoco', age: 1, type: 'Dog' },
  { name: 'Soneca', age: 2, type: 'Dog' },
  { name: 'Pregui√ßa', age: 5, type: 'Cat' },
];

const findAnimalsByType = (type) => (
  new Promise((resolve, reject) => {
    setTimeout(() => {
      const arrayAnimals = Animals.filter((animal) => animal.type === type);
      if (arrayAnimals.length !== 0) {
        return resolve(arrayAnimals);
      }

      return reject({ error: 'N√£o possui esse tipo de animal.' });
    }, 100);
  })
);

const getListAnimals = (type) => (
  findAnimalsByType(type).then(list => list)
);

describe('Quando o tipo do animal existe', () => {
  test('Retorne a lista de animais', () => {
    expect.assertions(2);
    return getListAnimals('Dog').then(listDogs => {
      expect(listDogs[0].name).toEqual('Dorminhoco');
      expect(listDogs[1].name).toEqual('Soneca');
    });
  });
});
/* Rode o teste e verifique se ele n√£o est√° dando algum falso-positivo. Mude o Dorminhoco
para Agitado . Viu? O teste n√£o passou, logo n√£o possui falso-positivos.
Agora veja o passo a passo de como o teste foi feito.
Primeiro criamos o describe, onde os testes ser√£o executados. */

describe('Quando o tipo do animal, existe', () => {
  test('Retorne a lista de animais', () => {

  });
});
/* Agora, adicione a fun√ß√£o a ser testada. Como ela retorna uma Promise , √© necess√°rio
adicionarmos o .then para pegar o seu resultado.
 */
describe('Quando o tipo do animal, existe', () => {
  test('Retorne a lista de animais', () => {
    getListAnimals('Dog').then(listDogs => {

    });
  });
});
// Agora adicione os testes e os execute.

describe('Quando o tipo do animal, existe', () => {
  test('Retorne a lista de animais', () => {
    getListAnimals('Dog').then(listDogs => {
      expect(listDogs[0].name).toEqual('Dorminhoco');
      expect(listDogs[1].name).toEqual('Soneca');
    });
  });
});
// Verifique se deu algum falso-positivo, mude o nome do Dorminhoco para Bob . Observe:

describe('Quando o tipo do animal, existe', () => {
  test('Retorne a lista de animais', () => {
    getListAnimals('Dog').then(listDogs => {
      expect(listDogs[0].name).toEqual('Bob');
      expect(listDogs[1].name).toEqual('Soneca');
    });
  });
});
/* O teste continuou passando sem encontrar o erro (o que n√£o era o esperado), o que indica
que ele est√° com um falso-positivo.
Para resolver esse problema, √© necess√°rio inserir um return antes da fun√ß√£o e, em
seguida, adicionar a quantidade de expect esperadas por meio do comando expect.assertions(2) . */

describe('Quando o tipo do animal, existe', () => {
  test('Retorne a lista de animais', () => {
    expect.assertions(2);
    return getListAnimals('Dog').then(listDogs => {
      expect(listDogs[0].name).toEqual('Bob');
      expect(listDogs[1].name).toEqual('Soneca');
    });
  });
});
/* Agora o teste conseguiu identificar o erro, retornando dois erros. Um dos erros √© o que
esperava Bob , mas recebeu o Dorminhoco . Como o Jest apenas recebeu 1 assertion, mas eram
esperados 2 , surge o segundo erro no nosso teste. Agora, desfa√ßa as altera√ß√µes para o teste
voltar a funcionar. Como esse teste conseguiu encontrar o erro, fica claro que o problema de
resultados falso-positivos foi resolvido.
Se quiser, remova o expect.assertions(2) e veja que o teste passa! */

describe('Quando o tipo do animal, existe', () => {
  test('Retorne a lista de animais', () => {
    return getListAnimals('Dog').then(listDogs => {
      expect(listDogs[0].name).toEqual('Dorminhoco');
      expect(listDogs[1].name).toEqual('Soneca');
    });
  });
});
/* Essa promise possui dois casos: quando ela funciona, ocorre o resolve e, no erro, ocorre
o reject . Como o resolve j√° foi testado, faltam apenas os testes do erro.
O c√≥digo abaixo testa, exatamente, o caso de erro. */

describe('Quando o tipo do animal, n√£o existe', () => {
  test('Retorne a lista de animais', () => {
    return getListAnimals('Lion').catch(error =>
      expect(error).toEqual({ error: "N√£o possui esse tipo de animal." })
    );
  });
});
/* Como o array Animals n√£o possui nenhum Lion (tipo inserido no teste), ser√° disparada a
reject , que retornar√° um objeto com uma chave error com o valor N√£o possui esse tipo de
animal. . A diferen√ßa entre esse teste e os outros √© o .catch no lugar do .then . O .catch
trabalha o resultado da promise quando ocorre um reject ; j√° o .then , quando ocorre o resolve .

Async/Await:
Para testar o c√≥digo Async/Await , ser√° usado o mesmo c√≥digo anterior, mas com pequenas
mudan√ßas. Observe: */

test('Testando com async/await', async () => {
  const listDogs = await getListAnimals('Dog');
  expect(listDogs[0].name).toEqual('Dorminhoco');
  expect(listDogs[1].name).toEqual('Soneca');
});
/* Perceba que a diferen√ßa entre elas √© o async . Como existe uma promise a ser testada,
√© necess√°rio o uso do await , para que o teste espere a finaliza√ß√£o da promise e, em seguida,
execute o teste remanescente. A vari√°vel listDogs recebe o retorno da promise e executa os testes.
Abaixo est√° o c√≥digo para quando ocorre o reject da promise. √â necess√°rio adicionar o bloco try/
atch . */

test('Testando com async/await, testando o reject', async () => {
  try {
    await getListAnimals('Lion');
  } catch (error) {
    expect(error).toEqual({ error: "N√£o possui esse tipo de animal." })
  }
});